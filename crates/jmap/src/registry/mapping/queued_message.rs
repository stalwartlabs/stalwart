/*
 * SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
 *
 * SPDX-License-Identifier: AGPL-3.0-only OR LicenseRef-SEL
 */

use crate::registry::mapping::RegistryGetResponse;
use common::{Server, config::smtp::queue::ArchivedQueueExpiry};
use registry::{
    jmap::IntoValue,
    schema::{
        enums::{DeliveryErrorType, MessageFlag, RecipientFlag},
        structs::{
            DeliveryError, QueueExpiry, QueueExpiryAttempts, QueueExpiryTtl, QueuedMessage,
            QueuedRecipient, RecipientStatus, ServerResponse,
        },
    },
    types::{datetime::UTCDateTime, ipaddr::IpAddr},
};
use smtp::queue::{spool::SmtpSpool, *};
use store::{
    IterateParams, U64_LEN, ValueKey,
    ahash::AHashSet,
    write::{QueueClass, ValueClass, key::DeserializeBigEndian},
};
use trc::AddContext;
use types::{blob::BlobId, blob_hash::BlobHash, id::Id};
use utils::DomainPart;

pub(crate) async fn queued_message_get(
    mut get: RegistryGetResponse<'_>,
) -> trc::Result<RegistryGetResponse<'_>> {
    let ids = if let Some(ids) = get.ids.take() {
        ids
    } else {
        queued_ids(get.server, get.server.core.jmap.get_max_objects)
            .await?
            .into_iter()
            .map(Id::from)
            .collect()
    };

    for id in ids {
        let Some(message_archive) = get.server.read_message_archive(id.id()).await? else {
            get.not_found(id);
            continue;
        };
        let message_in = message_archive.unarchive::<Message>()?;
        if get.access_token.tenant_id().is_some() {
            if let Some(domain) = message_in.return_path.try_domain_part()
                && let Some(domain) = get.server.domain(domain).await?
                && domain.id_tenant == get.access_token.tenant_id()
            {
                get.insert(id, map_message(message_in).into_value());
            } else {
                get.not_found(id);
            }
        } else {
            get.insert(id, map_message(message_in).into_value());
        }
    }

    Ok(get)
}

fn map_message(message_in: &ArchivedMessage) -> QueuedMessage {
    let mut message_out = QueuedMessage {
        blob_id: BlobId::new(BlobHash::from(&message_in.blob_hash), Default::default()),
        created_at: UTCDateTime::from_timestamp(message_in.created.to_native() as i64),
        env_id: message_in.env_id.as_ref().map(|v| v.to_string()),
        flags: Vec::with_capacity(1),
        priority: message_in.priority.to_native() as i64,
        received_from_ip: IpAddr(message_in.received_from_ip.as_ipaddr()),
        received_via_port: message_in.received_via_port.to_native() as u64,
        recipients: Vec::with_capacity(message_in.recipients.len()),
        return_path: message_in.return_path.to_string(),
        size: message_in.size.to_native(),
    };

    // Parse flags
    let flags = message_in.flags.to_native();
    for (bit, flag) in [
        (FROM_AUTHENTICATED, MessageFlag::Authenticated),
        (FROM_UNAUTHENTICATED, MessageFlag::Unauthenticated),
        (
            FROM_UNAUTHENTICATED_DMARC,
            MessageFlag::UnauthenticatedDmarc,
        ),
        (FROM_DSN, MessageFlag::Dsn),
        (FROM_REPORT, MessageFlag::Report),
        (FROM_AUTOGENERATED, MessageFlag::Autogenerated),
    ] {
        if flags & bit != 0 {
            message_out.flags.push(flag);
        }
    }

    // Parse recipients
    for rcpt_in in message_in.recipients.iter() {
        let mut rcpt_out = QueuedRecipient {
            address: rcpt_in.address.to_string(),
            expires: match &rcpt_in.expires {
                ArchivedQueueExpiry::Ttl(ttl) => QueueExpiry::Ttl(QueueExpiryTtl {
                    expires_at: UTCDateTime::from_timestamp(ttl.to_native() as i64),
                }),
                ArchivedQueueExpiry::Attempts(attempts) => {
                    QueueExpiry::Attempts(QueueExpiryAttempts {
                        expires_attempts: attempts.to_native() as u64,
                    })
                }
            },
            flags: vec![],
            notify_count: rcpt_in.notify.inner.to_native() as u64,
            notify_due: UTCDateTime::from_timestamp(rcpt_in.notify.due.to_native() as i64),
            orcpt: rcpt_in.orcpt.as_ref().map(|v| v.to_string()),
            queue_name: rcpt_in.queue.as_str().to_string(),
            retry_count: rcpt_in.retry.inner.to_native() as u64,
            retry_due: UTCDateTime::from_timestamp(rcpt_in.retry.due.to_native() as i64),
            status: match &rcpt_in.status {
                ArchivedStatus::Scheduled => RecipientStatus::Scheduled,
                ArchivedStatus::Completed(status) => RecipientStatus::Completed(ServerResponse {
                    response_code: (status.response.code.to_native() as u64).into(),
                    response_enhanced: build_enhanced_code(&status.response.esc).into(),
                    response_hostname: status.hostname.to_string().into(),
                    response_message: status.response.message.to_string().into(),
                }),
                ArchivedStatus::TemporaryFailure(status) => {
                    RecipientStatus::TemporaryFailure(map_error_details(status))
                }
                ArchivedStatus::PermanentFailure(status) => {
                    RecipientStatus::PermanentFailure(map_error_details(status))
                }
            },
        };

        // Parse recipient flags
        let rcpt_flags = rcpt_in.flags.to_native();
        for (bit, flag) in [
            (RCPT_DSN_SENT, RecipientFlag::DsnSent),
            (RCPT_SPAM_PAYLOAD, RecipientFlag::SpamPayload),
        ] {
            if rcpt_flags & bit != 0 {
                rcpt_out.flags.push(flag);
            }
        }

        message_out.recipients.push(rcpt_out);
    }

    message_out
}

fn map_error_details(err_in: &ArchivedErrorDetails) -> DeliveryError {
    let mut err_out = DeliveryError {
        response_hostname: err_in.entity.to_string().into(),
        ..Default::default()
    };

    match &err_in.details {
        ArchivedError::DnsError(e) => {
            err_out.error_type = DeliveryErrorType::DnsError;
            err_out.error_message = e.to_string().into();
        }
        ArchivedError::UnexpectedResponse(e) => {
            err_out.error_type = DeliveryErrorType::UnexpectedResponse;
            err_out.error_command = e.command.to_string().into();
            err_out.response_code = (e.response.code.to_native() as u64).into();
            err_out.response_enhanced = build_enhanced_code(&e.response.esc).into();
            err_out.response_message = e.response.message.to_string().into();
        }
        ArchivedError::ConnectionError(e) => {
            err_out.error_type = DeliveryErrorType::ConnectionError;
            err_out.error_message = e.to_string().into();
        }
        ArchivedError::TlsError(e) => {
            err_out.error_type = DeliveryErrorType::TlsError;
            err_out.error_message = e.to_string().into();
        }
        ArchivedError::DaneError(e) => {
            err_out.error_type = DeliveryErrorType::DaneError;
            err_out.error_message = e.to_string().into();
        }
        ArchivedError::MtaStsError(e) => {
            err_out.error_type = DeliveryErrorType::MtaStsError;
            err_out.error_message = e.to_string().into();
        }
        ArchivedError::RateLimited => {
            err_out.error_type = DeliveryErrorType::RateLimited;
        }
        ArchivedError::ConcurrencyLimited => {
            err_out.error_type = DeliveryErrorType::ConcurrencyLimited;
        }
        ArchivedError::Io(e) => {
            err_out.error_type = DeliveryErrorType::Io;
            err_out.error_message = e.to_string().into();
        }
    }

    err_out
}

fn build_enhanced_code(esc: &[u8; 3]) -> String {
    format!("{}.{}.{}", esc[0], esc[1], esc[2])
}

async fn queued_ids(server: &Server, max_results: usize) -> trc::Result<AHashSet<u64>> {
    let mut events = AHashSet::with_capacity(8);

    let from_key = ValueKey::from(ValueClass::Queue(QueueClass::MessageEvent(
        store::write::QueueEvent {
            due: 0,
            queue_id: 0,
            queue_name: [0; 8],
        },
    )));
    let to_key = ValueKey::from(ValueClass::Queue(QueueClass::MessageEvent(
        store::write::QueueEvent {
            due: u64::MAX,
            queue_id: u64::MAX,
            queue_name: [u8::MAX; 8],
        },
    )));

    server
        .store()
        .iterate(
            IterateParams::new(from_key, to_key).ascending().no_values(),
            |key, _| {
                events.insert(key.deserialize_be_u64(U64_LEN)?);

                Ok(events.len() < max_results)
            },
        )
        .await
        .caused_by(trc::location!())
        .map(|_| events)
}
